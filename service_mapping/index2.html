<!-- <!DOCTYPE html>
<html>
<head>
    <title>Advanced Contact Mapping Interface</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            background: #f5f5f5;
        }
        .container { 
            max-width: 1200px; 
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin: 0 auto;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            margin: -20px -20px 20px -20px;
            border-radius: 8px 8px 0 0;
        }
        .feature-tabs {
            margin: 20px 0;
        }
        .tab-content {
            padding: 20px;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 8px 8px;
        }
        .mapping-rule { 
            border: 1px solid #ddd; 
            padding: 20px; 
            margin: 15px 0; 
            display: flex; 
            align-items: flex-start;
            gap: 20px; 
            background: #f8f9fa;
            border-radius: 8px;
            position: relative;
        }
        .mapping-rule.suggested {
            border-color: #28a745;
            background: #f8fff9;
        }
        .field-container {
            flex: 1;
            position: relative;
        }
        .form-control {
            padding: 12px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 6px;
            width: 100%;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
        }
        .form-control:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .autocomplete-container {
            position: relative;
        }
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        .suggestion-item {
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            font-family: 'Courier New', monospace;
        }
        .suggestion-item:hover {
            background: #f8f9fa;
        }
        .suggestion-item.highlighted {
            background: #667eea;
            color: white;
        }
        .suggestion-match {
            font-weight: bold;
            color: #667eea;
        }
        .live-preview {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .preview-json {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .template-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .template-card:hover {
            border-color: #667eea;
            background: #f8f9fa;
        }
        .template-card.selected {
            border-color: #667eea;
            background: #e8f0fe;
        }
        .auto-suggestion {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            position: relative;
        }
        .suggestion-badge {
            position: absolute;
            top: -8px;
            right: 10px;
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
        }
        .confidence-score {
            font-size: 12px;
            color: #666;
            margin-left: 10px;
        }
        .big-arrow { 
            font-size: 28px; 
            color: #667eea; 
            margin-top: 40px;
            font-weight: bold;
        }
        .remove-btn { 
            background: #dc3545; 
            color: white; 
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            margin-top: 40px;
        }
        .add-btn { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; 
            font-size: 18px;
            border: none;
            border-radius: 8px;
            padding: 15px 30px;
        }
        .save-btn { 
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white; 
            font-size: 18px;
            border: none;
            border-radius: 8px;
            padding: 15px 40px;
        }
        label { 
            font-weight: bold; 
            display: block; 
            margin-bottom: 8px; 
            color: #2d3748;
        }
        .helper-text { 
            font-size: 12px; 
            color: #666; 
            margin-top: 5px;
        }
        .stats-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .nav-tabs .nav-link.active {
            background-color: #667eea;
            border-color: #667eea;
            color: white;
        }
        .nav-tabs .nav-link {
            color: #667eea;
            border-color: transparent;
        }
        .match-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 10px;
        }
        .match-high { background: #28a745; }
        .match-medium { background: #ffc107; }
        .match-low { background: #dc3545; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Advanced Mapping Interface</h1>
            <p>Smart field mapping with autocomplete, live preview, templates, and AI suggestions</p>
        </div>
        
        <div class="row">
            <div class="col-md-8">
                <div style="margin: 20px 0;">
                    <h3>Entity Type</h3>
                    <select id="entity-type" class="form-control" onchange="onEntityTypeChange()">
                        <option value="">Loading entity types...</option>
                    </select>
                </div>

                <!-- Feature Tabs -->
                <ul class="nav nav-tabs feature-tabs" id="featureTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="mapping-tab" data-bs-toggle="tab" data-bs-target="#mapping-panel" type="button">
                            üó∫Ô∏è Manual Mapping
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="templates-tab" data-bs-toggle="tab" data-bs-target="#templates-panel" type="button">
                            üìã Templates
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="suggestions-tab" data-bs-toggle="tab" data-bs-target="#suggestions-panel" type="button">
                            ü§ñ AI Suggestions
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="preview-tab" data-bs-toggle="tab" data-bs-target="#preview-panel" type="button">
                            üëÄ Live Preview
                        </button>
                    </li>
                </ul>

                <div class="tab-content">
                    <!-- Manual Mapping Panel -->
                    <div class="tab-pane fade show active" id="mapping-panel">
                        <div id="mapping-rules">
                            <!-- Rules will appear here -->
                        </div>
                        <button class="add-btn mt-3" onclick="addRule()">+ Add New Field Mapping</button>
                    </div>

                    <!-- Templates Panel -->
                    <div class="tab-pane fade" id="templates-panel">
                        <h4>Choose a Template</h4>
                        <p>Pre-built mapping configurations for common scenarios</p>
                        <div id="template-list">
                            <!-- Templates will be loaded here -->
                        </div>
                        <button class="btn btn-success" onclick="applySelectedTemplate()">Apply Selected Template</button>
                    </div>

                    <!-- AI Suggestions Panel -->
                    <div class="tab-pane fade" id="suggestions-panel">
                        <h4>Smart Field Detection</h4>
                        <p>AI-powered suggestions based on field name similarity</p>
                        <button class="btn btn-primary" onclick="generateSuggestions()">ü§ñ Generate Smart Suggestions</button>
                        <div id="suggestions-list">
                            <!-- Suggestions will appear here -->
                        </div>
                    </div>

                    <!-- Live Preview Panel -->
                    <div class="tab-pane fade" id="preview-panel">
                        <h4>Transformation Preview</h4>
                        <p>See how your data will look after transformation</p>
                        <div class="live-preview">
                            <strong>Sample Input Data:</strong>
                            <div class="preview-json" id="sample-input"></div>
                        </div>
                        <div class="live-preview mt-3">
                            <strong>Transformed Output:</strong>
                            <div class="preview-json" id="transformed-output"></div>
                        </div>
                        <button class="btn btn-info" onclick="updatePreview()">üîÑ Refresh Preview</button>
                    </div>
                </div>

                <div style="margin-top: 30px; text-align: center;">
                    <button class="save-btn" onclick="saveMapping()">üíæ Save Configuration</button>
                    <button class="btn btn-secondary ms-2" onclick="loadMapping()">üìÅ Load Current Settings</button>
                </div>
            </div>

            <!-- Stats Sidebar -->
            <div class="col-md-4">
                <div class="stats-card">
                    <h5>üìä Mapping Stats</h5>
                    <div id="mapping-stats">
                        <p>Rules: <span id="rules-count">0</span></p>
                        <p>Completion: <span id="completion-rate">0%</span></p>
                        <p>Confidence: <span id="confidence-score">0%</span></p>
                    </div>
                </div>

                <div class="live-preview">
                    <h6>üéØ Field Suggestions</h6>
                    <div id="dynamic-suggestions">
                        <p><em>Start typing in the fields above to see suggestions...</em></p>
                    </div>
                </div>

                <div class="live-preview mt-3">
                    <h6>üìã Quick Actions</h6>
                    <button class="btn btn-sm btn-outline-primary w-100 mb-2" onclick="exportMapping()">üì• Export JSON</button>
                    <button class="btn btn-sm btn-outline-secondary w-100 mb-2" onclick="importMapping()">üì§ Import JSON</button>
                    <button class="btn btn-sm btn-outline-info w-100" onclick="validateMapping()">‚úÖ Validate Rules</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // Global variables
        let fieldSuggestions = {
            contact: {
                source: ['id', 'first_name', 'last_name', 'email', 'phone', 'company', 'created_at', 'updated_at', 'aymene', 'custom_field'],
                destination: ['hubspot_id', 'properties.firstname', 'properties.lastname', 'properties.email', 'properties.phone', 'properties.company', 'properties.created_date', 'properties.last_modified_date', 'properties.haloui']
            },
            project: {
                source: ['id', 'name', 'description', 'status', 'start_date', 'end_date', 'budget', 'owner'],
                destination: ['hubspot_id', 'properties.name', 'properties.description', 'properties.hs_pipeline_stage', 'properties.start_date', 'properties.end_date', 'properties.budget']
            }
        };

        let selectedTemplate = null;
        let activeAutocomplete = null;

        // Templates
        const mappingTemplates = {
            contact: {
                'basic-contact': {
                    name: 'Basic Contact Fields',
                    description: 'Essential contact information mapping',
                    mappings: {
                        'id': 'hubspot_id',
                        'first_name': 'properties.firstname',
                        'last_name': 'properties.lastname',
                        'email': 'properties.email',
                        'phone': 'properties.phone',
                        'company': 'properties.company'
                    }
                },
                'full-contact': {
                    name: 'Complete Contact Profile',
                    description: 'Comprehensive contact mapping with dates',
                    mappings: {
                        'id': 'hubspot_id',
                        'first_name': 'properties.firstname',
                        'last_name': 'properties.lastname',
                        'email': 'properties.email',
                        'phone': 'properties.phone',
                        'company': 'properties.company',
                        'created_at': 'properties.created_date',
                        'updated_at': 'properties.last_modified_date'
                    }
                },
                'custom-example': {
                    name: 'Custom Fields Example',
                    description: 'Example with custom field mapping',
                    mappings: {
                        'aymene': 'properties.haloui',
                        'custom_field': 'properties.custom_property',
                        'special_id': 'properties.external_id'
                    }
                }
            }
        };

        // Sample data for preview
        const sampleData = {
            contact: {
                'id': 'c001',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john.doe@example.com',
                'phone': '+1234567890',
                'company': 'Acme Corp',
                'aymene': 'test_value',
                'created_at': '2023-01-15T10:30:00Z'
            }
        };

        // Initialize when page loads
        window.onload = function() {
            loadEntityTypes();
            updateStats();
        };

        // 1. AUTOCOMPLETE FUNCTIONALITY
        function setupAutocomplete(inputElement, suggestions, isSource = true) {
            const container = inputElement.parentElement;
            let suggestionsDiv = container.querySelector('.autocomplete-suggestions');
            
            if (!suggestionsDiv) {
                suggestionsDiv = document.createElement('div');
                suggestionsDiv.className = 'autocomplete-suggestions';
                container.appendChild(suggestionsDiv);
            }

            let highlightedIndex = -1;

            inputElement.addEventListener('input', function(e) {
                const value = e.target.value.toLowerCase();
                if (value.length < 1) {
                    suggestionsDiv.style.display = 'none';
                    return;
                }

                const filteredSuggestions = suggestions.filter(suggestion => 
                    suggestion.toLowerCase().includes(value)
                );

                if (filteredSuggestions.length === 0) {
                    suggestionsDiv.style.display = 'none';
                    return;
                }

                suggestionsDiv.innerHTML = '';
                suggestionsDiv.style.display = 'block';
                highlightedIndex = -1;

                filteredSuggestions.forEach((suggestion, index) => {
                    const div = document.createElement('div');
                    div.className = 'suggestion-item';
                    
                    // Highlight matching text
                    const highlightedText = suggestion.replace(
                        new RegExp(value, 'gi'), 
                        match => `<span class="suggestion-match">${match}</span>`
                    );
                    div.innerHTML = highlightedText;
                    
                    div.addEventListener('click', () => {
                        inputElement.value = suggestion;
                        suggestionsDiv.style.display = 'none';
                        updatePreview();
                        updateStats();
                        
                        // Trigger auto-suggestion for the other field
                        if (isSource) {
                            autoSuggestDestination(inputElement);
                        }
                    });
                    
                    suggestionsDiv.appendChild(div);
                });
            });

            inputElement.addEventListener('keydown', function(e) {
                const items = suggestionsDiv.querySelectorAll('.suggestion-item');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    highlightedIndex = Math.min(highlightedIndex + 1, items.length - 1);
                    updateHighlight(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    highlightedIndex = Math.max(highlightedIndex - 1, -1);
                    updateHighlight(items);
                } else if (e.key === 'Enter' && highlightedIndex >= 0) {
                    e.preventDefault();
                    items[highlightedIndex].click();
                } else if (e.key === 'Escape') {
                    suggestionsDiv.style.display = 'none';
                }
            });

            function updateHighlight(items) {
                items.forEach((item, index) => {
                    item.classList.toggle('highlighted', index === highlightedIndex);
                });
            }

            // Hide suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!container.contains(e.target)) {
                    suggestionsDiv.style.display = 'none';
                }
            });
        }

        // 2. FIELD RELATIONSHIP DETECTION
        function autoSuggestDestination(sourceInput) {
            const sourceValue = sourceInput.value.toLowerCase();
            const rule = sourceInput.closest('.mapping-rule');
            const destinationInput = rule.querySelector('.target-field');
            
            if (!sourceValue || destinationInput.value) return;

            const entityType = document.getElementById('entity-type').value;
            const suggestions = fieldSuggestions[entityType]?.destination || [];
            
            // Smart matching rules
            const matches = suggestions.filter(dest => {
                const destLower = dest.toLowerCase();
                return destLower.includes(sourceValue) || 
                       sourceValue.includes(destLower.split('.').pop()) ||
                       getLevenshteinDistance(sourceValue, destLower.split('.').pop()) <= 2;
            });

            if (matches.length > 0) {
                destinationInput.value = matches[0];
                destinationInput.style.background = '#d4edda';
                setTimeout(() => {
                    destinationInput.style.background = '';
                }, 2000);
                
                updatePreview();
                updateStats();
            }
        }

        // 3. TEMPLATES FUNCTIONALITY
        function loadTemplates() {
            const entityType = document.getElementById('entity-type').value;
            const templateList = document.getElementById('template-list');
            
            if (!entityType || !mappingTemplates[entityType]) {
                templateList.innerHTML = '<p>No templates available for this entity type.</p>';
                return;
            }

            templateList.innerHTML = '';
            Object.entries(mappingTemplates[entityType]).forEach(([key, template]) => {
                const card = document.createElement('div');
                card.className = 'template-card';
                card.onclick = () => selectTemplate(key, card);
                
                card.innerHTML = `
                    <h5>${template.name}</h5>
                    <p>${template.description}</p>
                    <small>Maps ${Object.keys(template.mappings).length} fields</small>
                `;
                
                templateList.appendChild(card);
            });
        }

        function selectTemplate(templateKey, cardElement) {
            document.querySelectorAll('.template-card').forEach(card => {
                card.classList.remove('selected');
            });
            cardElement.classList.add('selected');
            selectedTemplate = templateKey;
        }

        function applySelectedTemplate() {
            if (!selectedTemplate) {
                alert('Please select a template first');
                return;
            }

            const entityType = document.getElementById('entity-type').value;
            const template = mappingTemplates[entityType][selectedTemplate];
            
            // Clear existing rules
            document.getElementById('mapping-rules').innerHTML = '';
            
            // Add template mappings
            Object.entries(template.mappings).forEach(([source, destination]) => {
                addRule(source, destination);
            });
            
            updatePreview();
            updateStats();
            alert(`‚úÖ Applied template: ${template.name}`);
            
            // Switch to mapping tab
            document.getElementById('mapping-tab').click();
        }

        // 4. AI SUGGESTIONS FUNCTIONALITY
        function generateSuggestions() {
            const entityType = document.getElementById('entity-type').value;
            if (!entityType) {
                alert('Please select an entity type first');
                return;
            }

            const suggestionsList = document.getElementById('suggestions-list');
            suggestionsList.innerHTML = '<p>ü§ñ Analyzing field patterns...</p>';
            
            setTimeout(() => {
                const suggestions = generateSmartSuggestions(entityType);
                displaySuggestions(suggestions);
            }, 1000);
        }

        function generateSmartSuggestions(entityType) {
            const sources = fieldSuggestions[entityType]?.source || [];
            const destinations = fieldSuggestions[entityType]?.destination || [];
            
            const suggestions = [];
            
            sources.forEach(source => {
                destinations.forEach(destination => {
                    const confidence = calculateMatchConfidence(source, destination);
                    if (confidence > 0.6) {
                        suggestions.push({
                            source,
                            destination,
                            confidence,
                            reason: getMatchReason(source, destination)
                        });
                    }
                });
            });
            
            return suggestions.sort((a, b) => b.confidence - a.confidence);
        }

        function displaySuggestions(suggestions) {
            const suggestionsList = document.getElementById('suggestions-list');
            
            if (suggestions.length === 0) {
                suggestionsList.innerHTML = '<p>No high-confidence suggestions found.</p>';
                return;
            }
            
            suggestionsList.innerHTML = suggestions.map(suggestion => `
                <div class="auto-suggestion">
                    <div class="suggestion-badge">AI</div>
                    <strong>${suggestion.source}</strong> ‚Üí <strong>${suggestion.destination}</strong>
                    <span class="confidence-score">${Math.round(suggestion.confidence * 100)}% confidence</span>
                    <br><small>${suggestion.reason}</small>
                    <button class="btn btn-sm btn-success float-end" onclick="applySuggestion('${suggestion.source}', '${suggestion.destination}')">
                        Apply
                    </button>
                </div>
            `).join('');
        }

        function applySuggestion(source, destination) {
            addRule(source, destination);
            updatePreview();
            updateStats();
        }

        // 5. LIVE PREVIEW FUNCTIONALITY
        function updatePreview() {
            const entityType = document.getElementById('entity-type').value;
            if (!entityType) return;

            const sampleInput = document.getElementById('sample-input');
            const transformedOutput = document.getElementById('transformed-output');
            
            // Show sample input
            sampleInput.textContent = JSON.stringify(sampleData[entityType] || {}, null, 2);
            
            // Generate transformed output
            const rules = getCurrentMappingRules();
            const transformed = transformData(sampleData[entityType] || {}, rules);
            transformedOutput.textContent = JSON.stringify(transformed, null, 2);
        }

        function transformData(inputData, rules) {
            const result = {};
            
            Object.entries(rules).forEach(([source, destination]) => {
                if (inputData[source] !== undefined) {
                    if (destination.includes('.')) {
                        const [parent, child] = destination.split('.');
                        if (!result[parent]) result[parent] = {};
                        result[parent][child] = inputData[source];
                    } else {
                        result[destination] = inputData[source];
                    }
                }
            });
            
            return result;
        }

        // Helper Functions
        function calculateMatchConfidence(source, destination) {
            const sourceLower = source.toLowerCase();
            const destLower = destination.toLowerCase().split('.').pop();
            
            if (sourceLower === destLower) return 0.95;
            if (sourceLower.includes(destLower) || destLower.includes(sourceLower)) return 0.85;
            
            const distance = getLevenshteinDistance(sourceLower, destLower);
            const maxLength = Math.max(sourceLower.length, destLower.length);
            return Math.max(0, 1 - (distance / maxLength));
        }

        function getMatchReason(source, destination) {
            const reasons = [
                'Exact name match',
                'Partial name similarity',
                'Common field pattern',
                'Semantic similarity'
            ];
            return reasons[Math.floor(Math.random() * reasons.length)];
        }

        function getLevenshteinDistance(str1, str2) {
            const matrix = [];
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[str2.length][str1.length];
        }

        // Core Functions
        function onEntityTypeChange() {
            const entityType = document.getElementById('entity-type').value;
            if (entityType) {
                document.getElementById('mapping-rules').innerHTML = '';
                loadTemplates();
                updatePreview();
                updateStats();
            }
        }

        function addRule(sourceValue = '', targetValue = '') {
            const rulesDiv = document.getElementById('mapping-rules');
            const ruleDiv = document.createElement('div');
            ruleDiv.className = 'mapping-rule';
            
            const ruleId = Date.now();
            const entityType = document.getElementById('entity-type').value;
            
            ruleDiv.innerHTML = `
                <div class="field-container">
                    <label>Source Field:</label>
                    <div class="autocomplete-container">
                        <input type="text" class="form-control source-field" value="${sourceValue}" placeholder="e.g., first_name, aymene">
                    </div>
                    <div class="helper-text">Field from your source system</div>
                </div>
                
                <div class="big-arrow">‚Üí</div>
                
                <div class="field-container">
                    <label>Destination Field:</label>
                    <div class="autocomplete-container">
                        <input type="text" class="form-control target-field" value="${targetValue}" placeholder="e.g., properties.firstname">
                    </div>
                    <div class="helper-text">Destination field path</div>
                </div>
                
                <button class="remove-btn" onclick="removeRule(this)">‚úï</button>
            `;
            
            rulesDiv.appendChild(ruleDiv);
            
            // Setup autocomplete for new fields
            const sourceInput = ruleDiv.querySelector('.source-field');
            const targetInput = ruleDiv.querySelector('.target-field');
            
            if (fieldSuggestions[entityType]) {
                setupAutocomplete(sourceInput, fieldSuggestions[entityType].source, true);
                setupAutocomplete(targetInput, fieldSuggestions[entityType].destination, false);
            }
            
            // Add event listeners for live preview updates
            sourceInput.addEventListener('input', () => {
                updatePreview();
                updateStats();
            });
            
            targetInput.addEventListener('input', () => {
                updatePreview();
                updateStats();
            });
            
            updateStats();
        }

        function removeRule(button) {
            if (confirm('Are you sure you want to remove this mapping?')) {
                button.parentElement.remove();
                updatePreview();
                updateStats();
            }
        }

        function getCurrentMappingRules() {
            const rules = {};
            document.querySelectorAll('.mapping-rule').forEach(rule => {
                const sourceField = rule.querySelector('.source-field').value.trim();
                const targetField = rule.querySelector('.target-field').value.trim();
                
                if (sourceField && targetField) {
                    rules[sourceField] = targetField;
                }
            });
            return rules;
        }

        function updateStats() {
            const rules = getCurrentMappingRules();
            const rulesCount = Object.keys(rules).length;
            
            document.getElementById('rules-count').textContent = rulesCount;
            
            // Calculate completion rate (simple heuristic)
            const totalPossibleFields = 8; // Estimated common fields
            const completionRate = Math.min(100, Math.round((rulesCount / totalPossibleFields) * 100));
            document.getElementById('completion-rate').textContent = completionRate + '%';
            
            // Calculate confidence score based on field name similarity
            let totalConfidence = 0;
            let validRules = 0;
            
            Object.entries(rules).forEach(([source, destination]) => {
                const confidence = calculateMatchConfidence(source, destination.split('.').pop());
                totalConfidence += confidence;
                validRules++;
            });
            
            const avgConfidence = validRules > 0 ? Math.round((totalConfidence / validRules) * 100) : 0;
            document.getElementById('confidence-score').textContent = avgConfidence + '%';
            
            // Update dynamic suggestions
            updateDynamicSuggestions();
        }

        function updateDynamicSuggestions() {
            const entityType = document.getElementById('entity-type').value;
            const currentRules = getCurrentMappingRules();
            const suggestionsDiv = document.getElementById('dynamic-suggestions');
            
            if (!entityType || !fieldSuggestions[entityType]) {
                suggestionsDiv.innerHTML = '<p><em>No suggestions available</em></p>';
                return;
            }
            
            const unmappedSources = fieldSuggestions[entityType].source.filter(source => 
                !currentRules[source]
            );
            
            if (unmappedSources.length === 0) {
                suggestionsDiv.innerHTML = '<p>‚úÖ <em>All common fields mapped!</em></p>';
                return;
            }
            
            const suggestions = unmappedSources.slice(0, 3).map(source => {
                const bestMatch = fieldSuggestions[entityType].destination.find(dest => 
                    calculateMatchConfidence(source, dest.split('.').pop()) > 0.7
                );
                
                return `
                    <div style="margin: 5px 0; padding: 5px; background: #f8f9fa; border-radius: 4px; cursor: pointer;" 
                         onclick="addRule('${source}', '${bestMatch || ''}')">
                        <small><strong>${source}</strong> ‚Üí ${bestMatch || '?'}</small>
                    </div>
                `;
            }).join('');
            
            suggestionsDiv.innerHTML = suggestions || '<p><em>No suggestions</em></p>';
        }

        // API Integration Functions
        function loadEntityTypes() {
            fetch('/api/entity-types')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const entityTypeSelect = document.getElementById('entity-type');
                    entityTypeSelect.innerHTML = '';
                    
                    if (data.entity_types && data.entity_types.length > 0) {
                        data.entity_types.forEach(type => {
                            const option = document.createElement('option');
                            option.value = type.value;
                            option.textContent = type.label;
                            entityTypeSelect.appendChild(option);
                        });
                        
                        // Auto-select first option and load its data
                        entityTypeSelect.selectedIndex = 0;
                        onEntityTypeChange();
                    } else {
                        entityTypeSelect.innerHTML = '<option value="">No entity types available</option>';
                    }
                })
                .catch(err => {
                    console.error("Error loading entity types:", err);
                    document.getElementById('entity-type').innerHTML = '<option value="">Error loading types</option>';
                });
        }

        function loadMapping() {
            const entityType = document.getElementById('entity-type').value;
            
            if (!entityType) {
                alert('Please select an entity type first');
                return;
            }
            
            fetch(`/mappings/${entityType}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.error) {
                        alert(`No existing mapping found for ${entityType}. Create a new one!`);
                        return;
                    }
                    
                    const rules = data.rules || {};
                    if (Object.keys(rules).length === 0) {
                        alert(`No mapping rules found for ${entityType}.`);
                        return;
                    }
                    
                    // Clear existing rules
                    document.getElementById('mapping-rules').innerHTML = '';
                    
                    // Add loaded rules
                    Object.entries(rules).forEach(([source, target]) => {
                        addRule(source, target);
                    });
                    
                    updatePreview();
                    updateStats();
                    alert(`‚úÖ Loaded ${Object.keys(rules).length} mapping rules for ${entityType}`);
                })
                .catch(err => {
                    console.error("Error loading mappings:", err);
                    alert(`‚ùå Could not load mappings: ${err.message}`);
                });
        }

        function saveMapping() {
            const entityType = document.getElementById('entity-type').value;
            
            if (!entityType) {
                alert('Please select an entity type first');
                return;
            }
            
            const rules = getCurrentMappingRules();
            
            if (Object.keys(rules).length === 0) {
                alert('Please add at least one mapping rule before saving.');
                return;
            }
            
            // Validate rules
            for (const [source, target] of Object.entries(rules)) {
                if (source.includes(' ') || target.includes(' ')) {
                    alert(`Invalid field names cannot contain spaces: "${source}" ‚Üí "${target}"`);
                    return;
                }
            }
            
            console.log(`Saving ${Object.keys(rules).length} mapping rules for ${entityType}:`, rules);
            
            fetch(`/mappings/${entityType}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(rules)
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    alert(`‚úÖ Successfully saved ${Object.keys(rules).length} mapping rules for ${entityType}!`);
                } else {
                    alert(`Error saving: ${data.error || 'Unknown error'}`);
                }
            })
            .catch(err => {
                console.error("Error saving mappings:", err);
                alert('Error saving: ' + err.message);
            });
        }

        // Export/Import Functions
        function exportMapping() {
            const entityType = document.getElementById('entity-type').value;
            if (!entityType) {
                alert('Please select an entity type first');
                return;
            }
            
            const rules = getCurrentMappingRules();
            if (Object.keys(rules).length === 0) {
                alert('No mapping rules to export.');
                return;
            }
            
            const dataStr = JSON.stringify(rules, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${entityType}_mapping.json`;
            link.click();
            URL.revokeObjectURL(url);
            
            alert(`‚úÖ Exported ${Object.keys(rules).length} mapping rules`);
        }

        function importMapping() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const rules = JSON.parse(e.target.result);
                        
                        // Clear existing rules
                        document.getElementById('mapping-rules').innerHTML = '';
                        
                        // Add imported rules
                        Object.entries(rules).forEach(([source, target]) => {
                            addRule(source, target);
                        });
                        
                        updatePreview();
                        updateStats();
                        alert(`‚úÖ Imported ${Object.keys(rules).length} mapping rules from ${file.name}`);
                    } catch (error) {
                        alert(`‚ùå Error importing file: ${error.message}`);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        function validateMapping() {
            const rules = getCurrentMappingRules();
            const issues = [];
            
            if (Object.keys(rules).length === 0) {
                issues.push('No mapping rules defined');
            }
            
            // Check for validation issues
            Object.entries(rules).forEach(([source, target]) => {
                if (source.includes(' ')) {
                    issues.push(`Source field "${source}" contains spaces`);
                }
                if (target.includes(' ')) {
                    issues.push(`Destination field "${target}" contains spaces`);
                }
                if (!target.includes('.') && target !== 'hubspot_id') {
                    issues.push(`Destination "${target}" should use dot notation (e.g., properties.${target})`);
                }
            });
            
            // Check for duplicates
            const sources = Object.keys(rules);
            const destinations = Object.values(rules);
            
            const duplicateSources = sources.filter((item, index) => sources.indexOf(item) !== index);
            const duplicateDestinations = destinations.filter((item, index) => destinations.indexOf(item) !== index);
            
            if (duplicateSources.length > 0) {
                issues.push(`Duplicate source fields: ${duplicateSources.join(', ')}`);
            }
            if (duplicateDestinations.length > 0) {
                issues.push(`Duplicate destination fields: ${duplicateDestinations.join(', ')}`);
            }
            
            if (issues.length === 0) {
                alert('‚úÖ Mapping validation passed! No issues found.');
            } else {
                alert(`‚ùå Validation Issues Found:\n\n‚Ä¢ ${issues.join('\n‚Ä¢ ')}`);
            }
        }

        // Additional utility functions
        function clearAllMappings() {
            if (confirm('Are you sure you want to clear all mappings?')) {
                document.getElementById('mapping-rules').innerHTML = '';
                updatePreview();
                updateStats();
            }
        }

        function duplicateRule(button) {
            const rule = button.closest('.mapping-rule');
            const sourceValue = rule.querySelector('.source-field').value;
            const targetValue = rule.querySelector('.target-field').value;
            addRule(sourceValue + '_copy', targetValue + '_copy');
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 's':
                        e.preventDefault();
                        saveMapping();
                        break;
                    case 'n':
                        e.preventDefault();
                        addRule();
                        break;
                    case 'l':
                        e.preventDefault();
                        loadMapping();
                        break;
                }
            }
        });

        // Initialize preview on page load
        setTimeout(() => {
            updatePreview();
        }, 1000);
    </script>
</body>
</html>